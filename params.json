{"name":"Mouth","body":"# Mouth\r\n\r\nMouth is a Ruby daemon that collects stats via UDP and stores them in Mongo.  It comes with a modern UI that allows you to view graphs and create dashboards of these statistics.  Mouth is very similar to [StatsD](https://github.com/etsy/statsd) + [Graphite](http://graphite.wikidot.com/) + [Graphene](http://jondot.github.com/graphene/).\r\n\r\n\r\n## Why\r\n\r\nWhy duplicate effort of the excellent StatsD / Graphite packages?  I wanted a graphing and monitoring tool that offered:\r\n\r\n\r\n* **Accessible data**.  Because the metrics are stored in Mongo, they are very accessible to any scripts you want to write to read and act on your data.\r\n* **Easy installation**.  Mouth depends on just Ruby and Mongo, both incredibly easy to install.\r\n* **Modern, friendly UI**.  Mouth graphs are beautiful and easy to work with.  Exploring data and building dashboards are a joy.\r\n\r\n## Kinds of Metrics\r\n\r\nThere are two kinds of metrics currently: counters and timers.  Both are stored in a time series with minute granularity.\r\n\r\n* **Counters**:\r\n  * how many occurances of something happen per minute?\r\n  * Can be sampled\r\n  * Standard usage: Mouth.increment(\"myapp.happenings\")\r\n  * Advanced usage: Mouth.increment(\"myapp.happenings\", 1, 0.1) # 1/10 sample rate.  UDP packets are sent 1 in 10 times, but count for 1 * 10 each.\r\n  * Gives you a time series of happenings by minute: {\"myapp.happenings\" => [1, 2, 5, 20, ...]}\r\n* **Timers**:\r\n  * How long does something take?\r\n  * Standard usage: Mouth.measure(\"myapp.occurances\", 3.3) # This occurance took 3.3 ms to occur\r\n  * Standard usage 2: Mouth.measure(\"myapp.occurances\") { do_occurance() }\r\n  * Gives you a time series of occurance timings by minute: {\"myapp.happenings\" => [1, 2, 5, 20, ...]}\r\n* **Gauges**: (Coming soon)\r\n\r\n## Installation on OSX\r\n\r\nInstall mouth:\r\n\r\n    gem install mouth\r\n\r\nInstall MongoDB if you haven't:\r\n\r\n    brew install mongodb\r\n\r\nStart collector:\r\n\r\n    mouth\r\n\r\nStart web UI:\r\n\r\n    mouth-endoscope\r\n\r\nRecord a metric:\r\n\r\n    ruby -e 'require \"mouth\"; require \"mouth/instrument\"; Mouth.increment(\"gorets\")'\r\n\r\nTo load the web UI, go to http://0.0.0.0:5678/ (or whatever port got chosen -- see the Terminal).  Click 'Add Graph' in the lower right-hand corner.\r\n\r\n## Installation in Production\r\n\r\nYou'll want to follow the general gist of what you did for OSX, but make sure to specify your hosts, ports, and log locations.\r\nNOTE: there is no config file -- all options are via command-line.\r\n\r\n    sudo gem install mouth\r\n    mouth --pidfile /path/to/log/mouth.pid --logfile /path/to/log/mouth.log -H x.x.x.x -P 8889 --mongohost y.y.y.y --verbosity 1\r\n    mouth-endoscope --mongohost x.x.x.x\r\n\r\n## Instrumenting Your Application to Record Metrics\r\n\r\nThere are many ways to instrument your application:\r\n\r\n### Using the mouth gem\r\n\r\nMouth comes with a built-in facility to instrument your apps:\r\n    \r\n    require 'mouth'\r\n    require 'mouth/instrument'\r\n    \r\n    Mouth.server = \"0.0.0.0:8889\"\r\n    Mouth.increment('hello.world')\r\n    Mouth.measure('hello.happening', 42.9)\r\n    \r\n### Using mouth-instrument\r\n  \r\nmouth-instrument is a lightweight gem that doesn't have the baggage of the various gems that come with mouth. Its usage is nearly identical:\r\n    \r\n    gem install mouth-instrument\r\n\r\n    require 'mouth-instrument'\r\n    \r\n    Mouth.server = \"0.0.0.0:8889\"\r\n    Mouth.increment('hello.world')\r\n    Mouth.measure('hello.happening', 42.9)\r\n    \r\n### Using any StatsD instrumentation\r\n  \r\nMouth is StatsD compatible -- if you've instrumented your application to record StatsD metrics, it should work on Mouth.  Just replace your StatsD server with a mouth process.\r\n\r\n## Accessing Your Data Via Scripts\r\n\r\nYou can access and act on your metrics quite easily.\r\n\r\n  require 'mouth'\r\n  require 'mouth/sequence'\r\n  \r\n  Mouth.host = \"0.0.0.0:8889\"\r\n  Sequence.new(\"exceptions.app\", :kind => :counter).sequence\r\n  # => [4, 9, 0, ...]\r\n  \r\n  Sequence.new(\"app.requests\", :kind => :timer, :granularity_in_minutes => 15, :start_time => Time.now - 86400, :end_time => Time.now).sequence\r\n  # => [{:count => 3, :min => 1, :max => 30, :mean => 17.0, :sum => 51.0, :median => 20, :stddev => 12.02}, ...]\r\n\r\n## Tech\r\n\r\n* **Ruby** - 1.9.2+ is required.  Ruby was chosen because many Ruby shops already have it deployed as part of their infrastucture.  By putting everything in Ruby, node + python aren't needed.\r\n* **MongoDB** -  Mouth stores metrics in Mongo.  Mongo was chosen for 3 reasons:\r\n  * It's very easy to install and get going\r\n  * It has drivers for everything, so getting at your data is super easy\r\n  * It's schemaless design is fairly good for storing time series metrics.\r\n* **EventMachine** - Mouth is powered by EM, the Ruby way of doing nonblocking IO.\r\n* **Sinatra** - The web UI is served with a simple Sinatra app.\r\n* **Backbone.js** - The web UI is powered by Backbone.js\r\n* **D3.js** - The graphs are powered by D3.js\r\n\r\n\r\n## Contributing\r\n\r\nYou're interested in contributing to Mouth? *AWESOME*. Here are the basic steps:\r\n\r\nfork Mouth from here: http://github.com/cypriss/mouth\r\n\r\n1. Clone your fork\r\n2. Hack away\r\n3. If you are adding new functionality, document it in the README\r\n4. If necessary, rebase your commits into logical chunks, without errors\r\n5. Push the branch up to GitHub\r\n6. Send a pull request to the cypriss/mouth project.\r\n\r\n## Thanks\r\n\r\nThanks to UserVoice.com for sponsoring this project.  Thanks to the [StatsD](https://github.com/etsy/statsd) project for massive inspiration.  Other contributors: https://github.com/cypriss/mouth/graphs/contributors\r\n","tagline":"Collect and display statistics with Ruby + Mongo","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}